from __future__ import annotations

from bs4 import BeautifulSoup
from typing import Union, Optional, Any
from models import (
    TelegramType,
    TelegramMethod
)

import pathlib
import re

AUTOGENERATED_ALERT = """
# This is an autogenerated file. Do not edit this file directly.
# If you want to change the contents of this file, you should edit the
# corresponding file in the `botapi` package.\n\n
""".strip() + "\n\n"

CORE_URL = "https://core.telegram.org"
API_URL = CORE_URL + "/bots/api"

INVALID_TYPES = [
    "MaybeInaccessibleMessage",
    "InaccessibleMessage",
    "Games"
]
RAW_TYPES = ["int", "str", "float", "bool"]
TYPE_VALIDATORS = []

def to_snake_case(name: str) -> str:
    name = re.sub(r"(.)([A-Z][a-z]+)", r"\1_\2", name)
    name = re.sub(r"([a-z0-9])([A-Z])", r"\1_\2", name)
    return name.lower()

def tab(n: int, text: str = "") -> str:
    return (" " * (n * 4)) + text

def parse_telegram_type(value: str) -> Any:
    match = re.search(
        r"Array of (.+)", value,
        re.IGNORECASE
    )
    if match:
        value = match.group(1)
        return [parse_telegram_type(value)]
    if value in {"Integer", "Int"}:
        return "int"
    elif value == "String":
        return "str"
    elif value in {"Boolean", "True"}:
        return "bool"
    elif value in {"Float number", "Float"}:
        return "float"
    elif value == "Integer or String":
        return "int", "str"
    elif value == "InputFile or String":
        return "InputFile", "str"
    elif " or " in value or " and " in value:
        values = re.split(r" or | and |, ", value)
        return tuple(parse_telegram_type(x) for x in values)
    elif value in {"MaybeInaccessibleMessage", "Messages"}:
        return "Message"
    else:
        return value

def type_to_string(value: Any) -> str:
    if isinstance(value, tuple):
        return f"Union[{', '.join(type_to_string(x) for x in value)}]"
    elif isinstance(value, list):
        return f"List[{type_to_string(value[0])}]"
    else:
        return value

def is_type(title: str) -> bool:
    if len(title.split()) != 1:
        return False
    if not title[0].isupper():
        return False
    if title in INVALID_TYPES:
        return False
    return True

def is_method(title: str) -> bool:
    if len(title.split()) != 1:
        return False
    if not title[0].islower():
        return False
    return True

def break_text(text: str, n: int, add_tab: int = None) -> str:
    words = text.split()
    lines = []
    tab_prefix = ((" " * 4) * add_tab) \
        if add_tab else ""
    for i in range(0, len(words), n):
        line = " ".join(words[i:i + n])
        lines.append(f"{tab_prefix}{line}")
    return "\n".join(lines)

def return_type_to_string(type: Any) -> Optional[str]:
    if isinstance(type, list):
        value = type[0]
        if isinstance(value, list):
            return f"[{return_type_to_string(value)} for x in response]"
        if value in RAW_TYPES:
            return "return response"
        if value in TYPE_VALIDATORS:
            return f"return [TypeAdapter({value}).validate_python(x) for x in response]"
        else:
            return f"return [{value}.model_validate(x) for x in response]"
    if isinstance(type, tuple):
        if all(x in RAW_TYPES for x in type):
            return "response"
        for x in filter(lambda x: x not in RAW_TYPES, type):
            string = "try:\n"
            if x in TYPE_VALIDATORS:
                string += tab(3, f"return TypeAdapter({x}).validate_python(response)\n")
            else:
                string += tab(3, f"return {x}.model_validate(response)\n")
            string += tab(2, "except ValidationError:\n")
            string += tab(3, "pass\n")
        if any(x in RAW_TYPES for x in type):
            string += tab(2, f"return response")
        return string
    else:
        if type in RAW_TYPES:
            return "return response"
        if type in TYPE_VALIDATORS:
            return f"return TypeAdapter({type}).validate_python(response)"
        else:
            return f"return {type}.model_validate(response)"

def parse_return_value(description: str) -> Any:
    return_value_patterns = [
        r"on success.*?the edited ([a-zA-Z]+) is returned, otherwise ([a-zA-Z]+) is returned",
        r"on success.*?the edited ([a-zA-Z]+) is returned",
        r"returns.*?in form of a ([a-zA-Z]+) object.",
        r"on success, an ((?:Array\s+of\s+)+[a-zA-Z]+).*?returned.",
        r"returns the ([a-zA-Z]+) of the sent message.",
        r"the sent ([a-zA-Z]+) is returned",
        r"returns an ((?:Array\s+of\s+)+[a-zA-Z]+)",
        r"the (Message) is returned",
        r"on success, returns a ([a-zA-Z]+)",
        r"on success, ([a-zA-Z]+) is returned",
        r"returns ([a-zA-Z]+) on success",
        r"returns a ([a-zA-Z]+) object",
        r"a ([a-zA-Z]+) object is returned",
        r"returns.*?([a-zA-Z]+) on success",
        r"on success,.*?([a-zA-Z]+) is returned",
        r"returns.*?([a-zA-Z]+) object",
    ]
    for pattern in return_value_patterns:
        match = re.search(pattern, description, re.IGNORECASE)
        if match:
            if len(match.groups()) > 1:
                value = " or ".join(match.groups())
                return parse_telegram_type(value)
            return parse_telegram_type(match.group(1))
    return None

def write_generated_file(
    content: str,
    file_path: Union[pathlib.Path, str],
) -> None:
    content = AUTOGENERATED_ALERT + content
    with open(file_path, "w+") as file:
        file.write(content)

def search_by_string(
    soup: BeautifulSoup,
    name: str,
    string: str
) -> BeautifulSoup:
    items = soup.find_all(name)
    for item in items:
        if not item.text:
            continue
        if item.text.strip() == string:
            return item
            
def generate_type_string(type: TelegramType):
    string = ""
    string += f"class {type.name}(BaseModel):"
    string += "\n" + tab(1, '"""\n')
    string += break_text(type.description, 8, 1) + "\n"
    if type.anchor_link:
        string += "\n" + tab(1, f"Reference: {API_URL}{type.anchor_link}\n")
    string += tab(1, '"""\n')

    if type.is_empty:
        string += "\n" + tab(1, "pass\n")
        return string

    for parameter in sorted(type.parameters, key=lambda x: x.is_required, reverse=True):
        string_type = type_to_string(parameter.type)
        parameter_name = parameter.name
        if parameter.literal:
            string_type = f"Literal[\"{parameter.literal}\"]"
            string += "\n" + tab(1, f"{parameter_name}: {string_type} = \"{parameter.literal}\"")
        else:
            if not parameter.is_required:
                if parameter_name == "from":
                    parameter_name = f"from_{parameter.type.lower()}"
                    string += "\n" + tab(1, f"{parameter_name}: Optional[{string_type}] = Field(default=None, alias=\"from\")")
                else:
                    string += "\n" + tab(1, f"{parameter_name}: Optional[{string_type}] = Field(default=None)")
            else:
                if parameter_name == "from":
                    parameter_name = f"from_{parameter.type.lower()}"
                    string += "\n" + tab(1, f"{parameter_name}: {string_type} = Field(alias=\"from\")")
                else:
                    string += "\n" + tab(1, f"{parameter_name}: {string_type}")
    return string

def generate_parent_type_string(type: TelegramType):
    string = ""
    string += type.name + " = Union["
    for child in type.children:
        string += "\n" + tab(1, f"{child},")
    string += "\n]"

    return string

def generate_method_string(method: TelegramMethod):
    string = ""
    string += tab(1, f"async def {to_snake_case(method.name)}(")
    string += "\n" + tab(2, "self: botapi.BotAPI,")
    for parameter in sorted(
        method.parameters,
        key=lambda x: x.is_required,
        reverse=True
    ):
        string += "\n" + tab(2)
        parameter_type_string = type_to_string(parameter.type)
        if parameter.is_required:
            string += f"{parameter.name}: {parameter_type_string},"
        else:
            string += f"{parameter.name}: Optional[{parameter_type_string}] = None,"
    string += "\n" + tab(1) + ")"
    return_type_string = type_to_string(method.return_type)
    string += f" -> Optional[{return_type_string}]:"
    string += "\n" + tab(2, '"""\n')
    string += break_text(method.description, 8, 2) + "\n"
    if method.anchor_link:
        string += "\n" + tab(2, f"Reference: {API_URL}{method.anchor_link}\n")
    string += tab(2, '"""\n')
    string += "\n" + tab(2, "response = await self._send_request(")
    string += f"\"{method.name}\"," + " {"
    if len(method.parameters) == 0:
        string += "})"
    else:
        for parameter in method.parameters:
            if parameter.name == "parse_mode":
                string += "\n" + tab(3, f"\"{parameter.name}\": parse_mode or self.parse_mode,")
            else:
                string += "\n" + tab(3, f"\"{parameter.name}\": {parameter.name},")
        string += "\n" + tab(2) + "})"
    string += "\n" + tab(2, return_type_to_string(method.return_type))
    return string